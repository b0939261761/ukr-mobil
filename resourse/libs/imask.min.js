/*!
 * Version: 6.0.7
 */
!(function (t, e) { typeof exports === 'object' && typeof module !== 'undefined' ? e(exports) : typeof define === 'function' && define.amd ? define(['exports'], e) : e((t = typeof globalThis !== 'undefined' ? globalThis : t || self).IMask = {}); }(this, (t => {
  const e = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {}; function n(t) { const e = { exports: {} }; return t(e, e.exports), e.exports; } const u = function (t) { return t && t.Math == Math && t; }; const r = u(typeof globalThis === 'object' && globalThis) || u(typeof window === 'object' && window) || u(typeof self === 'object' && self) || u(typeof e === 'object' && e) || (function () { return this; }()) || Function('return this')(); const i = function (t) { try { return !!t(); } catch (t) { return !0; } }; const a = !i((() => Object.defineProperty({}, 1, { get() { return 7; } })[1] != 7)); const s = {}.propertyIsEnumerable; const o = Object.getOwnPropertyDescriptor; const l = { f: o && !s.call({ 1: 2 }, 1) ? function (t) { const e = o(this, t); return !!e && e.enumerable; } : s }; const h = function (t, e) {
    return {
      enumerable: !(1 & t), configurable: !(2 & t), writable: !(4 & t), value: e
    };
  }; const c = {}.toString; const f = ''.split; const p = i((() => !Object('z').propertyIsEnumerable(0))) ? function (t) { return (function (t) { return c.call(t).slice(8, -1); }(t)) == 'String' ? f.call(t, '') : Object(t); } : Object; const d = function (t) { if (t == null) throw TypeError(`Can't call method on ${t}`); return t; }; const v = function (t) { return p(d(t)); }; const k = function (t) { return typeof t === 'object' ? t !== null : typeof t === 'function'; }; const g = function (t, e) { if (!k(t)) return t; let n; let u; if (e && typeof (n = t.toString) === 'function' && !k(u = n.call(t))) return u; if (typeof (n = t.valueOf) === 'function' && !k(u = n.call(t))) return u; if (!e && typeof (n = t.toString) === 'function' && !k(u = n.call(t))) return u; throw TypeError("Can't convert object to primitive value"); }; const y = {}.hasOwnProperty; const m = function (t, e) { return y.call(t, e); }; const _ = r.document; const A = k(_) && k(_.createElement); const b = !a && !i((() => { return Object.defineProperty((t = 'div', A ? _.createElement(t) : {}), 'a', { get() { return 7; } }).a != 7; let t; })); const C = Object.getOwnPropertyDescriptor; const E = { f: a ? C : function (t, e) { if (t = v(t), e = g(e, !0), b) try { return C(t, e); } catch (t) {} if (m(t, e)) return h(!l.f.call(t, e), t[e]); } }; const F = function (t) { if (!k(t)) throw TypeError(`${String(t)} is not an object`); return t; }; const S = Object.defineProperty; const D = { f: a ? S : function (t, e, n) { if (F(t), e = g(e, !0), F(n), b) try { return S(t, e, n); } catch (t) {} if ('get' in n || 'set' in n) throw TypeError('Accessors not supported'); return 'value' in n && (t[e] = n.value), t; } }; const B = a ? function (t, e, n) { return D.f(t, e, h(1, n)); } : function (t, e, n) { return t[e] = n, t; }; const w = function (t, e) { try { B(r, t, e); } catch (n) { r[t] = e; } return e; }; const M = '__core-js_shared__'; const x = r[M] || w(M, {}); const P = Function.toString; typeof x.inspectSource !== 'function' && (x.inspectSource = function (t) { return P.call(t); }); let O; let T; let I; let j; const V = x.inspectSource; const R = r.WeakMap; const L = typeof R === 'function' && /native code/.test(V(R)); const N = n((t => { (t.exports = function (t, e) { return x[t] || (x[t] = void 0 !== e ? e : {}); })('versions', []).push({ version: '3.8.3', mode: 'global', copyright: 'Â© 2021 Denis Pushkarev (zloirock.ru)' }); })); let U = 0; const z = Math.random(); const H = N('keys'); const Y = {}; const Z = r.WeakMap; if (L) { const K = x.state || (x.state = new Z()); const G = K.get; const W = K.has; const $ = K.set; O = function (t, e) { return e.facade = t, $.call(K, t, e), e; }, T = function (t) { return G.call(K, t) || {}; }, I = function (t) { return W.call(K, t); }; } else { const q = H[j = 'state'] || (H[j] = (function (t) { return `Symbol(${String(void 0 === t ? '' : t)})_${(++U + z).toString(36)}`; }(j))); Y[q] = !0, O = function (t, e) { return e.facade = t, B(t, q, e), e; }, T = function (t) { return m(t, q) ? t[q] : {}; }, I = function (t) { return m(t, q); }; } const X = {
    set: O, get: T, has: I, enforce(t) { return I(t) ? T(t) : O(t, {}); }, getterFor(t) { return function (e) { let n; if (!k(e) || (n = T(e)).type !== t) throw TypeError(`Incompatible receiver, ${t} required`); return n; }; }
  }; const J = n((t => { const e = X.get; const n = X.enforce; const u = String(String).split('String'); (t.exports = function (t, e, i, a) { let s; const o = !!a && !!a.unsafe; let l = !!a && !!a.enumerable; const h = !!a && !!a.noTargetGet; typeof i === 'function' && (typeof e !== 'string' || m(i, 'name') || B(i, 'name', e), (s = n(i)).source || (s.source = u.join(typeof e === 'string' ? e : ''))), t !== r ? (o ? !h && t[e] && (l = !0) : delete t[e], l ? t[e] = i : B(t, e, i)) : l ? t[e] = i : w(e, i); })(Function.prototype, 'toString', (function () { return typeof this === 'function' && e(this).source || V(this); })); })); const Q = r; const tt = function (t) { return typeof t === 'function' ? t : void 0; }; const et = function (t, e) { return arguments.length < 2 ? tt(Q[t]) || tt(r[t]) : Q[t] && Q[t][e] || r[t] && r[t][e]; }; const nt = Math.ceil; const ut = Math.floor; const rt = function (t) { return isNaN(t = +t) ? 0 : (t > 0 ? ut : nt)(t); }; const it = Math.min; const at = function (t) { return t > 0 ? it(rt(t), 9007199254740991) : 0; }; const st = Math.max; const ot = Math.min; const lt = function (t) { return function (e, n, u) { let r; const i = v(e); const a = at(i.length); let s = (function (t, e) { const n = rt(t); return n < 0 ? st(n + e, 0) : ot(n, e); }(u, a)); if (t && n != n) { for (;a > s;) if ((r = i[s++]) != r) return !0; } else for (;a > s; s++) if ((t || s in i) && i[s] === n) return t || s || 0; return !t && -1; }; }; const ht = { includes: lt(!0), indexOf: lt(!1) }.indexOf; const ct = function (t, e) { let n; const u = v(t); let r = 0; const i = []; for (n in u)!m(Y, n) && m(u, n) && i.push(n); for (;e.length > r;)m(u, n = e[r++]) && (~ht(i, n) || i.push(n)); return i; }; const ft = ['constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf']; const pt = ft.concat('length', 'prototype'); const dt = { f: Object.getOwnPropertyNames || function (t) { return ct(t, pt); } }; const vt = { f: Object.getOwnPropertySymbols }; const kt = et('Reflect', 'ownKeys') || function (t) { const e = dt.f(F(t)); const n = vt.f; return n ? e.concat(n(t)) : e; }; const gt = function (t, e) { for (let n = kt(e), u = D.f, r = E.f, i = 0; i < n.length; i++) { const a = n[i]; m(t, a) || u(t, a, r(e, a)); } }; const yt = /#|\.prototype\./; const mt = function (t, e) { const n = At[_t(t)]; return n == Ct || n != bt && (typeof e === 'function' ? i(e) : !!e); }; var _t = mt.normalize = function (t) { return String(t).replace(yt, '.').toLowerCase(); }; var At = mt.data = {}; var bt = mt.NATIVE = 'N'; var Ct = mt.POLYFILL = 'P'; const Et = mt; const Ft = E.f; const St = function (t, e) { let n; let u; let i; let a; let s; const o = t.target; const l = t.global; const h = t.stat; if (n = l ? r : h ? r[o] || w(o, {}) : (r[o] || {}).prototype) for (u in e) { if (a = e[u], i = t.noTargetGet ? (s = Ft(n, u)) && s.value : n[u], !Et(l ? u : o + (h ? '.' : '#') + u, t.forced) && void 0 !== i) { if (typeof a === typeof i) continue; gt(a, i); }(t.sham || i && i.sham) && B(a, 'sham', !0), J(n, u, a, t); } }; const Dt = Object.keys || function (t) { return ct(t, ft); }; const Bt = function (t) { return Object(d(t)); }; const wt = Object.assign; const Mt = Object.defineProperty; const xt = !wt || i((() => { if (a && ({ b: 1, ...wt(Mt({}, 'a', { enumerable: !0, get() { Mt(this, 'b', { value: 3, enumerable: !1 }); } }), { b: 2 }) }).b !== 1) return !0; const t = {}; const e = {}; const n = Symbol(); const u = 'abcdefghijklmnopqrst'; return t[n] = 7, u.split('').forEach((t => { e[t] = t; })), ({ ...t })[n] != 7 || Dt({ ...e }).join('') != u; })) ? function (t, e) { for (var n = Bt(t), u = arguments.length, r = 1, i = vt.f, s = l.f; u > r;) for (var o, h = p(arguments[r++]), c = i ? Dt(h).concat(i(h)) : Dt(h), f = c.length, d = 0; f > d;)o = c[d++], a && !s.call(h, o) || (n[o] = h[o]); return n; } : wt; St({ target: 'Object', stat: !0, forced: Object.assign !== xt }, { assign: xt }); const Pt = ''.repeat || function (t) { let e = String(d(this)); let n = ''; let u = rt(t); if (u < 0 || u == 1 / 0) throw RangeError('Wrong number of repetitions'); for (;u > 0; (u >>>= 1) && (e += e))1 & u && (n += e); return n; }; const Ot = Math.ceil; const Tt = function (t) { return function (e, n, u) { let r; let i; const a = String(d(e)); const s = a.length; const o = void 0 === u ? ' ' : String(u); const l = at(n); return l <= s || o == '' ? a : (r = l - s, (i = Pt.call(o, Ot(r / o.length))).length > r && (i = i.slice(0, r)), t ? a + i : i + a); }; }; const It = { start: Tt(!1), end: Tt(!0) }; const jt = et('navigator', 'userAgent') || ''; const Vt = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(jt); const Rt = It.end; St({ target: 'String', proto: !0, forced: Vt }, { padEnd(t) { return Rt(this, t, arguments.length > 1 ? arguments[1] : void 0); } }); const Lt = It.start; function Nt(t) { return (Nt = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (t) { return typeof t; } : function (t) { return t && typeof Symbol === 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t; })(t); } function Ut(t, e) { if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function'); } function zt(t, e) { for (let n = 0; n < e.length; n++) { const u = e[n]; u.enumerable = u.enumerable || !1, u.configurable = !0, 'value' in u && (u.writable = !0), Object.defineProperty(t, u.key, u); } } function Ht(t, e, n) { return e && zt(t.prototype, e), n && zt(t, n), t; } function Yt(t, e) { if (typeof e !== 'function' && e !== null) throw new TypeError('Super expression must either be null or a function'); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), e && Kt(t, e); } function Zt(t) { return (Zt = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) { return t.__proto__ || Object.getPrototypeOf(t); })(t); } function Kt(t, e) { return (Kt = Object.setPrototypeOf || function (t, e) { return t.__proto__ = e, t; })(t, e); } function Gt(t, e) { if (t == null) return {}; let n; let u; const r = (function (t, e) { if (t == null) return {}; let n; let u; const r = {}; const i = Object.keys(t); for (u = 0; u < i.length; u++)n = i[u], e.indexOf(n) >= 0 || (r[n] = t[n]); return r; }(t, e)); if (Object.getOwnPropertySymbols) { const i = Object.getOwnPropertySymbols(t); for (u = 0; u < i.length; u++)n = i[u], e.indexOf(n) >= 0 || Object.prototype.propertyIsEnumerable.call(t, n) && (r[n] = t[n]); } return r; } function Wt(t, e) { return !e || typeof e !== 'object' && typeof e !== 'function' ? (function (t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t; }(t)) : e; } function $t(t) { const e = (function () { if (typeof Reflect === 'undefined' || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if (typeof Proxy === 'function') return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], (() => {}))), !0; } catch (t) { return !1; } }()); return function () { let n; const u = Zt(t); if (e) { const r = Zt(this).constructor; n = Reflect.construct(u, arguments, r); } else n = u.apply(this, arguments); return Wt(this, n); }; } function qt(t, e) { for (;!Object.prototype.hasOwnProperty.call(t, e) && (t = Zt(t)) !== null;);return t; } function Xt(t, e, n) { return (Xt = typeof Reflect !== 'undefined' && Reflect.get ? Reflect.get : function (t, e, n) { const u = qt(t, e); if (u) { const r = Object.getOwnPropertyDescriptor(u, e); return r.get ? r.get.call(n) : r.value; } })(t, e, n || t); } function Jt(t, e, n, u) {
    return (Jt = typeof Reflect !== 'undefined' && Reflect.set ? Reflect.set : function (t, e, n, u) {
      let r; const i = qt(t, e); if (i) { if ((r = Object.getOwnPropertyDescriptor(i, e)).set) return r.set.call(u, n), !0; if (!r.writable) return !1; } if (r = Object.getOwnPropertyDescriptor(u, e)) { if (!r.writable) return !1; r.value = n, Object.defineProperty(u, e, r); } else {
        !(function (t, e, n) {
          e in t ? Object.defineProperty(t, e, {
            value: n, enumerable: !0, configurable: !0, writable: !0
          }) : t[e] = n;
        }(u, e, n));
      } return !0;
    })(t, e, n, u);
  } function Qt(t, e, n, u, r) { if (!Jt(t, e, n, u || t) && r) throw new Error('failed to set property'); return n; } function te(t, e) { return (function (t) { if (Array.isArray(t)) return t; }(t)) || (function (t, e) { if (typeof Symbol === 'undefined' || !(Symbol.iterator in Object(t))) return; const n = []; let u = !0; let r = !1; let i = void 0; try { for (var a, s = t[Symbol.iterator](); !(u = (a = s.next()).done) && (n.push(a.value), !e || n.length !== e); u = !0); } catch (t) { r = !0, i = t; } finally { try { u || s.return == null || s.return(); } finally { if (r) throw i; } } return n; }(t, e)) || (function (t, e) { if (!t) return; if (typeof t === 'string') return ee(t, e); let n = Object.prototype.toString.call(t).slice(8, -1); n === 'Object' && t.constructor && (n = t.constructor.name); if (n === 'Map' || n === 'Set') return Array.from(t); if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return ee(t, e); }(t, e)) || (function () { throw new TypeError('Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'); }()); } function ee(t, e) { (e == null || e > t.length) && (e = t.length); for (var n = 0, u = new Array(e); n < e; n++)u[n] = t[n]; return u; } function ne(t) { return typeof t === 'string' || t instanceof String; }St({ target: 'String', proto: !0, forced: Vt }, { padStart(t) { return Lt(this, t, arguments.length > 1 ? arguments[1] : void 0); } }), St({ target: 'String', proto: !0 }, { repeat: Pt }), St({ global: !0 }, { globalThis: r }); const ue = 'NONE'; const re = 'LEFT'; const ie = 'FORCE_LEFT'; const ae = 'RIGHT'; const se = 'FORCE_RIGHT'; function oe(t) { switch (t) { case re: return ie; case ae: return se; default: return t; } } function le(t) { return t.replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1'); } function he(t, e) { if (e === t) return !0; let n; const u = Array.isArray(e); const r = Array.isArray(t); if (u && r) { if (e.length != t.length) return !1; for (n = 0; n < e.length; n++) if (!he(e[n], t[n])) return !1; return !0; } if (u != r) return !1; if (e && t && Nt(e) === 'object' && Nt(t) === 'object') { const i = e instanceof Date; const a = t instanceof Date; if (i && a) return e.getTime() == t.getTime(); if (i != a) return !1; const s = e instanceof RegExp; const o = t instanceof RegExp; if (s && o) return e.toString() == t.toString(); if (s != o) return !1; const l = Object.keys(e); for (n = 0; n < l.length; n++) if (!Object.prototype.hasOwnProperty.call(t, l[n])) return !1; for (n = 0; n < l.length; n++) if (!he(t[l[n]], e[l[n]])) return !1; return !0; } return !(!e || !t || typeof e !== 'function' || typeof t !== 'function') && e.toString() === t.toString(); } const ce = (function () { function t(e, n, u, r) { for (Ut(this, t), this.value = e, this.cursorPos = n, this.oldValue = u, this.oldSelection = r; this.value.slice(0, this.startChangePos) !== this.oldValue.slice(0, this.startChangePos);)--this.oldSelection.start; } return Ht(t, [{ key: 'startChangePos', get() { return Math.min(this.cursorPos, this.oldSelection.start); } }, { key: 'insertedCount', get() { return this.cursorPos - this.startChangePos; } }, { key: 'inserted', get() { return this.value.substr(this.startChangePos, this.insertedCount); } }, { key: 'removedCount', get() { return Math.max(this.oldSelection.end - this.startChangePos || this.oldValue.length - this.value.length, 0); } }, { key: 'removed', get() { return this.oldValue.substr(this.startChangePos, this.removedCount); } }, { key: 'head', get() { return this.value.substring(0, this.startChangePos); } }, { key: 'tail', get() { return this.value.substring(this.startChangePos + this.insertedCount); } }, { key: 'removeDirection', get() { return !this.removedCount || this.insertedCount ? ue : this.oldSelection.end === this.cursorPos || this.oldSelection.start === this.cursorPos ? ae : re; } }]), t; }()); const fe = (function () {
    function t(e) {
      Ut(this, t), Object.assign(this, {
        inserted: '', rawInserted: '', skip: !1, tailShift: 0
      }, e);
    } return Ht(t, [{ key: 'aggregate', value(t) { return this.rawInserted += t.rawInserted, this.skip = this.skip || t.skip, this.inserted += t.inserted, this.tailShift += t.tailShift, this; } }, { key: 'offset', get() { return this.tailShift + this.inserted.length; } }]), t;
  }()); const pe = (function () { function t() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ''; const n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0; const u = arguments.length > 2 ? arguments[2] : void 0; Ut(this, t), this.value = e, this.from = n, this.stop = u; } return Ht(t, [{ key: 'toString', value() { return this.value; } }, { key: 'extend', value(t) { this.value += String(t); } }, { key: 'appendTo', value(t) { return t.append(this.toString(), { tail: !0 }).aggregate(t._appendPlaceholder()); } }, { key: 'state', get() { return { value: this.value, from: this.from, stop: this.stop }; }, set(t) { Object.assign(this, t); } }, { key: 'shiftBefore', value(t) { if (this.from >= t || !this.value.length) return ''; const e = this.value[0]; return this.value = this.value.slice(1), e; } }]), t; }()); function de(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; return new de.InputMask(t, e); } const ve = (function () {
    function t(e) { Ut(this, t), this._value = '', this._update({ ...t.DEFAULTS, ...e }), this.isInitialized = !0; } return Ht(t, [{ key: 'updateOptions', value(t) { Object.keys(t).length && this.withValueRefresh(this._update.bind(this, t)); } }, { key: '_update', value(t) { Object.assign(this, t); } }, { key: 'state', get() { return { _value: this.value }; }, set(t) { this._value = t._value; } }, { key: 'reset', value() { this._value = ''; } }, { key: 'value', get() { return this._value; }, set(t) { this.resolve(t); } }, { key: 'resolve', value(t) { return this.reset(), this.append(t, { input: !0 }, ''), this.doCommit(), this.value; } }, { key: 'unmaskedValue', get() { return this.value; }, set(t) { this.reset(), this.append(t, {}, ''), this.doCommit(); } }, { key: 'typedValue', get() { return this.doParse(this.value); }, set(t) { this.value = this.doFormat(t); } }, { key: 'rawInputValue', get() { return this.extractInput(0, this.value.length, { raw: !0 }); }, set(t) { this.reset(), this.append(t, { raw: !0 }, ''), this.doCommit(); } }, { key: 'isComplete', get() { return !0; } }, { key: 'nearestInputPos', value(t, e) { return t; } }, { key: 'extractInput', value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length; return this.value.slice(t, e); } }, { key: 'extractTail', value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length; return new pe(this.extractInput(t, e), t); } }, { key: 'appendTail', value(t) { return ne(t) && (t = new pe(String(t))), t.appendTo(this); } }, { key: '_appendCharRaw', value(t) { return t ? (this._value += t, new fe({ inserted: t, rawInserted: t })) : new fe(); } }, { key: '_appendChar', value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const n = arguments.length > 2 ? arguments[2] : void 0; const u = this.state; let r = this._appendCharRaw(this.doPrepare(t, e), e); if (r.inserted) { let i; let a = !1 !== this.doValidate(e); if (a && n != null) { const s = this.state; this.overwrite && (i = n.state, n.shiftBefore(this.value.length)); const o = this.appendTail(n); (a = o.rawInserted === n.toString()) && o.inserted && (this.state = s); }a || (r = new fe(), this.state = u, n && i && (n.state = i)); } return r; } }, { key: '_appendPlaceholder', value() { return new fe(); } }, {
      key: 'append',
      value(t, e, n) {
        if (!ne(t)) throw new Error('value should be string'); const u = new fe(); const
          r = ne(n) ? new pe(String(n)) : n; e && e.tail && (e._beforeTailState = this.state); for (let i = 0; i < t.length; ++i)u.aggregate(this._appendChar(t[i], e, r)); return r != null && (u.tailShift += this.appendTail(r).tailShift), u;
      }
    }, { key: 'remove', value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length; return this._value = this.value.slice(0, t) + this.value.slice(e), new fe(); } }, { key: 'withValueRefresh', value(t) { if (this._refreshing || !this.isInitialized) return t(); this._refreshing = !0; const e = this.rawInputValue; const n = this.value; const u = t(); return this.rawInputValue = e, this.value && this.value !== n && n.indexOf(this.value) === 0 && this.append(n.slice(this.value.length), {}, ''), delete this._refreshing, u; } }, { key: 'runIsolated', value(t) { if (this._isolated || !this.isInitialized) return t(this); this._isolated = !0; const e = this.state; const n = t(this); return this.state = e, delete this._isolated, n; } }, { key: 'doPrepare', value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; return this.prepare ? this.prepare(t, this, e) : t; } }, { key: 'doValidate', value(t) { return (!this.validate || this.validate(this.value, this, t)) && (!this.parent || this.parent.doValidate(t)); } }, { key: 'doCommit', value() { this.commit && this.commit(this.value, this); } }, { key: 'doFormat', value(t) { return this.format ? this.format(t, this) : t; } }, { key: 'doParse', value(t) { return this.parse ? this.parse(t, this) : t; } }, { key: 'splice', value(t, e, n, u) { const r = t + e; const i = this.extractTail(r); const a = this.nearestInputPos(t, u); return new fe({ tailShift: a - t }).aggregate(this.remove(a)).aggregate(this.append(n, { input: !0 }, i)); } }]), t;
  }()); function ke(t) { if (t == null) throw new Error('mask property should be defined'); return t instanceof RegExp ? de.MaskedRegExp : ne(t) ? de.MaskedPattern : t instanceof Date || t === Date ? de.MaskedDate : t instanceof Number || typeof t === 'number' || t === Number ? de.MaskedNumber : Array.isArray(t) || t === Array ? de.MaskedDynamic : de.Masked && t.prototype instanceof de.Masked ? t : t instanceof Function ? de.MaskedFunction : t instanceof de.Masked ? t.constructor : (console.warn('Mask not found for mask', t), de.Masked); } function ge(t) { if (de.Masked && t instanceof de.Masked) return t; const e = (t = { ...t }).mask; if (de.Masked && e instanceof de.Masked) return e; const n = ke(e); if (!n) throw new Error('Masked class is not found for provided mask, appropriate module needs to be import manually before creating mask.'); return new n(t); }ve.DEFAULTS = { format(t) { return t; }, parse(t) { return t; } }, de.Masked = ve, de.createMask = ge; const ye = { 0: /\d/, a: /[\u0041-\u005A\u0061-\u007A\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/, '*': /./ }; const me = (function () { function t(e) { Ut(this, t); const n = e.mask; const u = Gt(e, ['mask']); this.masked = ge({ mask: n }), Object.assign(this, u); } return Ht(t, [{ key: 'reset', value() { this._isFilled = !1, this.masked.reset(); } }, { key: 'remove', value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length; return t === 0 && e >= 1 ? (this._isFilled = !1, this.masked.remove(t, e)) : new fe(); } }, { key: 'value', get() { return this.masked.value || (this._isFilled && !this.isOptional ? this.placeholderChar : ''); } }, { key: 'unmaskedValue', get() { return this.masked.unmaskedValue; } }, { key: 'isComplete', get() { return Boolean(this.masked.value) || this.isOptional; } }, { key: '_appendChar', value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if (this._isFilled) return new fe(); const n = this.masked.state; const u = this.masked._appendChar(t, e); return u.inserted && !1 === this.doValidate(e) && (u.inserted = u.rawInserted = '', this.masked.state = n), u.inserted || this.isOptional || this.lazy || e.input || (u.inserted = this.placeholderChar), u.skip = !u.inserted && !this.isOptional, this._isFilled = Boolean(u.inserted), u; } }, { key: 'append', value() { let t; return (t = this.masked).append.apply(t, arguments); } }, { key: '_appendPlaceholder', value() { const t = new fe(); return this._isFilled || this.isOptional || (this._isFilled = !0, t.inserted = this.placeholderChar), t; } }, { key: 'extractTail', value() { let t; return (t = this.masked).extractTail.apply(t, arguments); } }, { key: 'appendTail', value() { let t; return (t = this.masked).appendTail.apply(t, arguments); } }, { key: 'extractInput', value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length; const n = arguments.length > 2 ? arguments[2] : void 0; return this.masked.extractInput(t, e, n); } }, { key: 'nearestInputPos', value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ue; const n = 0; const u = this.value.length; const r = Math.min(Math.max(t, n), u); switch (e) { case re: case ie: return this.isComplete ? r : n; case ae: case se: return this.isComplete ? r : u; case ue: default: return r; } } }, { key: 'doValidate', value() { let t; let e; return (t = this.masked).doValidate.apply(t, arguments) && (!this.parent || (e = this.parent).doValidate.apply(e, arguments)); } }, { key: 'doCommit', value() { this.masked.doCommit(); } }, { key: 'state', get() { return { masked: this.masked.state, _isFilled: this._isFilled }; }, set(t) { this.masked.state = t.masked, this._isFilled = t._isFilled; } }]), t; }()); const _e = (function () { function t(e) { Ut(this, t), Object.assign(this, e), this._value = ''; } return Ht(t, [{ key: 'value', get() { return this._value; } }, { key: 'unmaskedValue', get() { return this.isUnmasking ? this.value : ''; } }, { key: 'reset', value() { this._isRawInput = !1, this._value = ''; } }, { key: 'remove', value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this._value.length; return this._value = this._value.slice(0, t) + this._value.slice(e), this._value || (this._isRawInput = !1), new fe(); } }, { key: 'nearestInputPos', value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ue; const n = 0; const u = this._value.length; switch (e) { case re: case ie: return n; case ue: case ae: case se: default: return u; } } }, { key: 'extractInput', value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this._value.length; const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; return n.raw && this._isRawInput && this._value.slice(t, e) || ''; } }, { key: 'isComplete', get() { return !0; } }, { key: '_appendChar', value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const n = new fe(); if (this._value) return n; const u = this.char === t[0]; const r = u && (this.isUnmasking || e.input || e.raw) && !e.tail; return r && (n.rawInserted = this.char), this._value = n.inserted = this.char, this._isRawInput = r && (e.raw || e.input), n; } }, { key: '_appendPlaceholder', value() { const t = new fe(); return this._value || (this._value = t.inserted = this.char), t; } }, { key: 'extractTail', value() { return arguments.length > 1 && void 0 !== arguments[1] || this.value.length, new pe(''); } }, { key: 'appendTail', value(t) { return ne(t) && (t = new pe(String(t))), t.appendTo(this); } }, { key: 'append', value(t, e, n) { const u = this._appendChar(t, e); return n != null && (u.tailShift += this.appendTail(n).tailShift), u; } }, { key: 'doCommit', value() {} }, { key: 'state', get() { return { _value: this._value, _isRawInput: this._isRawInput }; }, set(t) { Object.assign(this, t); } }]), t; }()); const Ae = (function () {
    function t() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []; const n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0; Ut(this, t), this.chunks = e, this.from = n; } return Ht(t, [{ key: 'toString', value() { return this.chunks.map(String).join(''); } }, { key: 'extend', value(e) { if (String(e)) { ne(e) && (e = new pe(String(e))); const n = this.chunks[this.chunks.length - 1]; const u = n && (n.stop === e.stop || e.stop == null) && e.from === n.from + n.toString().length; if (e instanceof pe)u ? n.extend(e.toString()) : this.chunks.push(e); else if (e instanceof t) { if (e.stop == null) for (var r; e.chunks.length && e.chunks[0].stop == null;)(r = e.chunks.shift()).from += e.from, this.extend(r); e.toString() && (e.stop = e.blockIndex, this.chunks.push(e)); } } } }, { key: 'appendTo', value(e) { if (!(e instanceof de.MaskedPattern)) return new pe(this.toString()).appendTo(e); for (var n = new fe(), u = 0; u < this.chunks.length && !n.skip; ++u) { const r = this.chunks[u]; const i = e._mapPosToBlock(e.value.length); const a = r.stop; let s = void 0; if (a != null && (!i || i.index <= a) && ((r instanceof t || e._stops.indexOf(a) >= 0) && n.aggregate(e._appendPlaceholder(a)), s = r instanceof t && e._blocks[a]), s) { const o = s.appendTail(r); o.skip = !1, n.aggregate(o), e._value += o.inserted; const l = r.toString().slice(o.rawInserted.length); l && n.aggregate(e.append(l, { tail: !0 })); } else n.aggregate(e.append(r.toString(), { tail: !0 })); } return n; } }, {
      key: 'state',
      get() {
        return {
          chunks: this.chunks.map((t => t.state)), from: this.from, stop: this.stop, blockIndex: this.blockIndex
        };
      },
      set(e) { const n = e.chunks; const u = Gt(e, ['chunks']); Object.assign(this, u), this.chunks = n.map((e => { const n = 'chunks' in e ? new t() : new pe(); return n.state = e, n; })); }
    }, { key: 'shiftBefore', value(t) { if (this.from >= t || !this.chunks.length) return ''; for (let e = t - this.from, n = 0; n < this.chunks.length;) { const u = this.chunks[n]; const r = u.shiftBefore(e); if (u.toString()) { if (!r) break; ++n; } else this.chunks.splice(n, 1); if (r) return r; } return ''; } }]), t;
  }()); const be = (function (t) { Yt(n, t); const e = $t(n); function n() { return Ut(this, n), e.apply(this, arguments); } return Ht(n, [{ key: '_update', value(t) { t.mask && (t.validate = function (e) { return e.search(t.mask) >= 0; }), Xt(Zt(n.prototype), '_update', this).call(this, t); } }]), n; }(ve)); de.MaskedRegExp = be; const Ce = (function (t) {
    Yt(n, t); const e = $t(n); function n() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return Ut(this, n), t.definitions = { ...ye, ...t.definitions }, e.call(this, { ...n.DEFAULTS, ...t }); } return Ht(n, [{ key: '_update', value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; t.definitions = { ...this.definitions, ...t.definitions }, Xt(Zt(n.prototype), '_update', this).call(this, t), this._rebuildMask(); } }, {
      key: '_rebuildMask',
      value() {
        const t = this; const e = this.definitions; this._blocks = [], this._stops = [], this._maskedBlocks = {}; const u = this.mask; if (u && e) {
          for (var r = !1, i = !1, a = 0; a < u.length; ++a) {
            if (this.blocks) if ((function () { const e = u.slice(a); const n = Object.keys(t.blocks).filter((t => e.indexOf(t) === 0)); n.sort(((t, e) => e.length - t.length)); const r = n[0]; if (r) { const i = ge({
 parent: t, lazy: t.lazy, placeholderChar: t.placeholderChar, overwrite: t.overwrite, ...t.blocks[r]
}); return i && (t._blocks.push(i), t._maskedBlocks[r] || (t._maskedBlocks[r] = []), t._maskedBlocks[r].push(t._blocks.length - 1)), a += r.length - 1, 'continue'; } }()) === 'continue') continue; let s = u[a]; let o = s in e; if (s !== n.STOP_CHAR) {
              if (s !== '{' && s !== '}') {
 if (s !== '[' && s !== ']') {
                if (s === n.ESCAPE_CHAR) { if (++a, !(s = u[a])) break; o = !1; } const l = o ? new me({
                  parent: this, lazy: this.lazy, placeholderChar: this.placeholderChar, mask: e[s], isOptional: i
                }) : new _e({ char: s, isUnmasking: r }); this._blocks.push(l);
              } else i = !i;
} else r = !r;
            } else this._stops.push(this._blocks.length);
          }
        }
      }
    }, { key: 'state', get() { return { ...Xt(Zt(n.prototype), 'state', this), _blocks: this._blocks.map((t => t.state)) }; }, set(t) { const e = t._blocks; const u = Gt(t, ['_blocks']); this._blocks.forEach(((t, n) => t.state = e[n])), Qt(Zt(n.prototype), 'state', u, this, !0); } }, { key: 'reset', value() { Xt(Zt(n.prototype), 'reset', this).call(this), this._blocks.forEach((t => t.reset())); } }, { key: 'isComplete', get() { return this._blocks.every((t => t.isComplete)); } }, { key: 'doCommit', value() { this._blocks.forEach((t => t.doCommit())), Xt(Zt(n.prototype), 'doCommit', this).call(this); } }, { key: 'unmaskedValue', get() { return this._blocks.reduce(((t, e) => t + e.unmaskedValue), ''); }, set(t) { Qt(Zt(n.prototype), 'unmaskedValue', t, this, !0); } }, { key: 'value', get() { return this._blocks.reduce(((t, e) => t + e.value), ''); }, set(t) { Qt(Zt(n.prototype), 'value', t, this, !0); } }, { key: 'appendTail', value(t) { return Xt(Zt(n.prototype), 'appendTail', this).call(this, t).aggregate(this._appendPlaceholder()); } }, { key: '_appendCharRaw', value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const n = this._mapPosToBlock(this.value.length); const u = new fe(); if (!n) return u; for (let r = n.index; ;++r) { const i = this._blocks[r]; if (!i) break; const a = i._appendChar(t, e); const s = a.skip; if (u.aggregate(a), s || a.rawInserted) break; } return u; } }, { key: 'extractTail', value() { const t = this; const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; const n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length; const u = new Ae(); return e === n || this._forEachBlocksInRange(e, n, ((e, n, r, i) => { const a = e.extractTail(r, i); a.stop = t._findStopBefore(n), a.from = t._blockStartPos(n), a instanceof Ae && (a.blockIndex = n), u.extend(a); })), u; } }, { key: 'extractInput', value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length; const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; if (t === e) return ''; let u = ''; return this._forEachBlocksInRange(t, e, ((t, e, r, i) => { u += t.extractInput(r, i, n); })), u; } }, { key: '_findStopBefore', value(t) { for (var e, n = 0; n < this._stops.length; ++n) { const u = this._stops[n]; if (!(u <= t)) break; e = u; } return e; } }, { key: '_appendPlaceholder', value(t) { const e = this; const n = new fe(); if (this.lazy && t == null) return n; const u = this._mapPosToBlock(this.value.length); if (!u) return n; const r = u.index; const i = t != null ? t : this._blocks.length; return this._blocks.slice(r, i).forEach((u => { if (!u.lazy || t != null) { const r = u._blocks != null ? [u._blocks.length] : []; const i = u._appendPlaceholder.apply(u, r); e._value += i.inserted, n.aggregate(i); } })), n; } }, { key: '_mapPosToBlock', value(t) { for (let e = '', n = 0; n < this._blocks.length; ++n) { const u = this._blocks[n]; const r = e.length; if (t <= (e += u.value).length) return { index: n, offset: t - r }; } } }, { key: '_blockStartPos', value(t) { return this._blocks.slice(0, t).reduce(((t, e) => t + e.value.length), 0); } }, { key: '_forEachBlocksInRange', value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length; const n = arguments.length > 2 ? arguments[2] : void 0; const u = this._mapPosToBlock(t); if (u) { const r = this._mapPosToBlock(e); const i = r && u.index === r.index; const a = u.offset; const s = r && i ? r.offset : this._blocks[u.index].value.length; if (n(this._blocks[u.index], u.index, a, s), r && !i) { for (let o = u.index + 1; o < r.index; ++o)n(this._blocks[o], o, 0, this._blocks[o].value.length); n(this._blocks[r.index], r.index, 0, r.offset); } } } }, { key: 'remove', value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length; const u = Xt(Zt(n.prototype), 'remove', this).call(this, t, e); return this._forEachBlocksInRange(t, e, ((t, e, n, r) => { u.aggregate(t.remove(n, r)); })), u; } }, { key: 'nearestInputPos', value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ue; const n = this._mapPosToBlock(t) || { index: 0, offset: 0 }; const u = n.offset; const r = n.index; const i = this._blocks[r]; if (!i) return t; let a = u; a !== 0 && a < i.value.length && (a = i.nearestInputPos(u, oe(e))); const s = a === i.value.length; const o = a === 0; if (!o && !s) return this._blockStartPos(r) + a; const l = s ? r + 1 : r; if (e === ue) { if (l > 0) { const h = l - 1; const c = this._blocks[h]; const f = c.nearestInputPos(0, ue); if (!c.value.length || f !== c.value.length) return this._blockStartPos(l); } for (let p = l, d = p; d < this._blocks.length; ++d) { const v = this._blocks[d]; const k = v.nearestInputPos(0, ue); if (!v.value.length || k !== v.value.length) return this._blockStartPos(d) + k; } for (let g = l - 1; g >= 0; --g) { const y = this._blocks[g]; const m = y.nearestInputPos(0, ue); if (!y.value.length || m !== y.value.length) return this._blockStartPos(g) + y.value.length; } return t; } if (e === re || e === ie) { for (var _, A = l; A < this._blocks.length; ++A) if (this._blocks[A].value) { _ = A; break; } if (_ != null) { const b = this._blocks[_]; const C = b.nearestInputPos(0, ae); if (C === 0 && b.unmaskedValue.length) return this._blockStartPos(_) + C; } for (var E, F = -1, S = l - 1; S >= 0; --S) { const D = this._blocks[S]; const B = D.nearestInputPos(D.value.length, ie); if (D.value && B === 0 || (E = S), B !== 0) { if (B !== D.value.length) return this._blockStartPos(S) + B; F = S; break; } } if (e === re) for (let w = F + 1; w <= Math.min(l, this._blocks.length - 1); ++w) { const M = this._blocks[w]; const x = M.nearestInputPos(0, ue); const P = this._blockStartPos(w) + x; if (P > t) break; if (x !== M.value.length) return P; } if (F >= 0) return this._blockStartPos(F) + this._blocks[F].value.length; if (e === ie || this.lazy && !this.extractInput() && !Ee(this._blocks[l])) return 0; if (E != null) return this._blockStartPos(E); for (let O = l; O < this._blocks.length; ++O) { const T = this._blocks[O]; const I = T.nearestInputPos(0, ue); if (!T.value.length || I !== T.value.length) return this._blockStartPos(O) + I; } return 0; } if (e === ae || e === se) { for (var j, V, R = l; R < this._blocks.length; ++R) { const L = this._blocks[R]; const N = L.nearestInputPos(0, ue); if (N !== L.value.length) { V = this._blockStartPos(R) + N, j = R; break; } } if (j != null && V != null) { for (let U = j; U < this._blocks.length; ++U) { const z = this._blocks[U]; const H = z.nearestInputPos(0, se); if (H !== z.value.length) return this._blockStartPos(U) + H; } return e === se ? this.value.length : V; } for (let Y = Math.min(l, this._blocks.length - 1); Y >= 0; --Y) { const Z = this._blocks[Y]; const K = Z.nearestInputPos(Z.value.length, re); if (K !== 0) { const G = this._blockStartPos(Y) + K; if (G >= t) return G; break; } } } return t; } }, { key: 'maskedBlock', value(t) { return this.maskedBlocks(t)[0]; } }, { key: 'maskedBlocks', value(t) { const e = this; const n = this._maskedBlocks[t]; return n ? n.map((t => e._blocks[t])) : []; } }]), n;
  }(ve)); function Ee(t) { if (!t) return !1; const e = t.value; return !e || t.nearestInputPos(0, ue) !== e.length; }Ce.DEFAULTS = { lazy: !0, placeholderChar: '_' }, Ce.STOP_CHAR = '`', Ce.ESCAPE_CHAR = '\\', Ce.InputDefinition = me, Ce.FixedDefinition = _e, de.MaskedPattern = Ce; const Fe = (function (t) { Yt(n, t); const e = $t(n); function n() { return Ut(this, n), e.apply(this, arguments); } return Ht(n, [{ key: '_matchFrom', get() { return this.maxLength - String(this.from).length; } }, { key: '_update', value(t) { t = { to: this.to || 0, from: this.from || 0, ...t }; let e = String(t.to).length; t.maxLength != null && (e = Math.max(e, t.maxLength)), t.maxLength = e; for (var u = String(t.from).padStart(e, '0'), r = String(t.to).padStart(e, '0'), i = 0; i < r.length && r[i] === u[i];)++i; t.mask = r.slice(0, i).replace(/0/g, '\\0') + '0'.repeat(e - i), Xt(Zt(n.prototype), '_update', this).call(this, t); } }, { key: 'isComplete', get() { return Xt(Zt(n.prototype), 'isComplete', this) && Boolean(this.value); } }, { key: 'boundaries', value(t) { let e = ''; let n = ''; const u = te(t.match(/^(\D*)(\d*)(\D*)/) || [], 3); const r = u[1]; const i = u[2]; return i && (e = '0'.repeat(r.length) + i, n = '9'.repeat(r.length) + i), [e = e.padEnd(this.maxLength, '0'), n = n.padEnd(this.maxLength, '9')]; } }, { key: 'doPrepare', value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if (t = Xt(Zt(n.prototype), 'doPrepare', this).call(this, t, e).replace(/\D/g, ''), !this.autofix) return t; for (var u = String(this.from).padStart(this.maxLength, '0'), r = String(this.to).padStart(this.maxLength, '0'), i = this.value, a = '', s = 0; s < t.length; ++s) { const o = i + a + t[s]; const l = this.boundaries(o); const h = te(l, 2); const c = h[0]; const f = h[1]; Number(f) < this.from ? a += u[o.length - 1] : Number(c) > this.to ? a += r[o.length - 1] : a += t[s]; } return a; } }, { key: 'doValidate', value() { let t; const e = this.value; const u = e.search(/[^0]/); if (u === -1 && e.length <= this._matchFrom) return !0; for (var r = this.boundaries(e), i = te(r, 2), a = i[0], s = i[1], o = arguments.length, l = new Array(o), h = 0; h < o; h++)l[h] = arguments[h]; return this.from <= Number(s) && Number(a) <= this.to && (t = Xt(Zt(n.prototype), 'doValidate', this)).call.apply(t, [this].concat(l)); } }]), n; }(Ce)); de.MaskedRange = Fe; const Se = (function (t) { Yt(n, t); const e = $t(n); function n(t) { return Ut(this, n), e.call(this, { ...n.DEFAULTS, ...t }); } return Ht(n, [{ key: '_update', value(t) { t.mask === Date && delete t.mask, t.pattern && (t.mask = t.pattern); const e = t.blocks; t.blocks = { ...n.GET_DEFAULT_BLOCKS() }, t.min && (t.blocks.Y.from = t.min.getFullYear()), t.max && (t.blocks.Y.to = t.max.getFullYear()), t.min && t.max && t.blocks.Y.from === t.blocks.Y.to && (t.blocks.m.from = t.min.getMonth() + 1, t.blocks.m.to = t.max.getMonth() + 1, t.blocks.m.from === t.blocks.m.to && (t.blocks.d.from = t.min.getDate(), t.blocks.d.to = t.max.getDate())), Object.assign(t.blocks, e), Object.keys(t.blocks).forEach((e => { const n = t.blocks[e]; 'autofix' in n || (n.autofix = t.autofix); })), Xt(Zt(n.prototype), '_update', this).call(this, t); } }, { key: 'doValidate', value() { for (var t, e = this.date, u = arguments.length, r = new Array(u), i = 0; i < u; i++)r[i] = arguments[i]; return (t = Xt(Zt(n.prototype), 'doValidate', this)).call.apply(t, [this].concat(r)) && (!this.isComplete || this.isDateExist(this.value) && e != null && (this.min == null || this.min <= e) && (this.max == null || e <= this.max)); } }, { key: 'isDateExist', value(t) { return this.format(this.parse(t, this), this).indexOf(t) >= 0; } }, { key: 'date', get() { return this.typedValue; }, set(t) { this.typedValue = t; } }, { key: 'typedValue', get() { return this.isComplete ? Xt(Zt(n.prototype), 'typedValue', this) : null; }, set(t) { Qt(Zt(n.prototype), 'typedValue', t, this, !0); } }]), n; }(Ce)); Se.DEFAULTS = { pattern: 'd{.}`m{.}`Y', format(t) { return [String(t.getDate()).padStart(2, '0'), String(t.getMonth() + 1).padStart(2, '0'), t.getFullYear()].join('.'); }, parse(t) { const e = te(t.split('.'), 3); const n = e[0]; const u = e[1]; const r = e[2]; return new Date(r, u - 1, n); } }, Se.GET_DEFAULT_BLOCKS = function () {
    return {
      d: {
        mask: Fe, from: 1, to: 31, maxLength: 2
      },
      m: {
        mask: Fe, from: 1, to: 12, maxLength: 2
      },
      Y: { mask: Fe, from: 1900, to: 9999 }
    };
  }, de.MaskedDate = Se; const De = (function () { function t() { Ut(this, t); } return Ht(t, [{ key: 'selectionStart', get() { let t; try { t = this._unsafeSelectionStart; } catch (t) {} return t != null ? t : this.value.length; } }, { key: 'selectionEnd', get() { let t; try { t = this._unsafeSelectionEnd; } catch (t) {} return t != null ? t : this.value.length; } }, { key: 'select', value(t, e) { if (t != null && e != null && (t !== this.selectionStart || e !== this.selectionEnd)) try { this._unsafeSelect(t, e); } catch (t) {} } }, { key: '_unsafeSelect', value(t, e) {} }, { key: 'isActive', get() { return !1; } }, { key: 'bindEvents', value(t) {} }, { key: 'unbindEvents', value() {} }]), t; }()); de.MaskElement = De; const Be = (function (t) { Yt(n, t); const e = $t(n); function n(t) { let u; return Ut(this, n), (u = e.call(this)).input = t, u._handlers = {}, u; } return Ht(n, [{ key: 'rootElement', get() { return this.input.getRootNode ? this.input.getRootNode() : document; } }, { key: 'isActive', get() { return this.input === this.rootElement.activeElement; } }, { key: '_unsafeSelectionStart', get() { return this.input.selectionStart; } }, { key: '_unsafeSelectionEnd', get() { return this.input.selectionEnd; } }, { key: '_unsafeSelect', value(t, e) { this.input.setSelectionRange(t, e); } }, { key: 'value', get() { return this.input.value; }, set(t) { this.input.value = t; } }, { key: 'bindEvents', value(t) { const e = this; Object.keys(t).forEach((u => e._toggleEventHandler(n.EVENTS_MAP[u], t[u]))); } }, { key: 'unbindEvents', value() { const t = this; Object.keys(this._handlers).forEach((e => t._toggleEventHandler(e))); } }, { key: '_toggleEventHandler', value(t, e) { this._handlers[t] && (this.input.removeEventListener(t, this._handlers[t]), delete this._handlers[t]), e && (this.input.addEventListener(t, e), this._handlers[t] = e); } }]), n; }(De)); Be.EVENTS_MAP = {
    selectionChange: 'keydown', input: 'input', drop: 'drop', click: 'click', focus: 'focus', commit: 'blur'
  }, de.HTMLMaskElement = Be; const we = (function (t) { Yt(n, t); const e = $t(n); function n() { return Ut(this, n), e.apply(this, arguments); } return Ht(n, [{ key: '_unsafeSelectionStart', get() { const t = this.rootElement; const e = t.getSelection && t.getSelection(); return e && e.anchorOffset; } }, { key: '_unsafeSelectionEnd', get() { const t = this.rootElement; const e = t.getSelection && t.getSelection(); return e && this._unsafeSelectionStart + String(e).length; } }, { key: '_unsafeSelect', value(t, e) { if (this.rootElement.createRange) { const n = this.rootElement.createRange(); n.setStart(this.input.firstChild || this.input, t), n.setEnd(this.input.lastChild || this.input, e); const u = this.rootElement; const r = u.getSelection && u.getSelection(); r && (r.removeAllRanges(), r.addRange(n)); } } }, { key: 'value', get() { return this.input.textContent; }, set(t) { this.input.textContent = t; } }]), n; }(Be)); de.HTMLContenteditableMaskElement = we; const Me = (function () {
    function t(e, n) { Ut(this, t), this.el = e instanceof De ? e : e.isContentEditable && e.tagName !== 'INPUT' && e.tagName !== 'TEXTAREA' ? new we(e) : new Be(e), this.masked = ge(n), this._listeners = {}, this._value = '', this._unmaskedValue = '', this._saveSelection = this._saveSelection.bind(this), this._onInput = this._onInput.bind(this), this._onChange = this._onChange.bind(this), this._onDrop = this._onDrop.bind(this), this._onFocus = this._onFocus.bind(this), this._onClick = this._onClick.bind(this), this.alignCursor = this.alignCursor.bind(this), this.alignCursorFriendly = this.alignCursorFriendly.bind(this), this._bindEvents(), this.updateValue(), this._onChange(); } return Ht(t, [{ key: 'mask', get() { return this.masked.mask; }, set(t) { if (!this.maskEquals(t)) if (t instanceof de.Masked || this.masked.constructor !== ke(t)) { const e = ge({ mask: t }); e.unmaskedValue = this.masked.unmaskedValue, this.masked = e; } else this.masked.updateOptions({ mask: t }); } }, { key: 'maskEquals', value(t) { return t == null || t === this.masked.mask || t === Date && this.masked instanceof Se; } }, { key: 'value', get() { return this._value; }, set(t) { this.masked.value = t, this.updateControl(), this.alignCursor(); } }, { key: 'unmaskedValue', get() { return this._unmaskedValue; }, set(t) { this.masked.unmaskedValue = t, this.updateControl(), this.alignCursor(); } }, { key: 'typedValue', get() { return this.masked.typedValue; }, set(t) { this.masked.typedValue = t, this.updateControl(), this.alignCursor(); } }, {
      key: '_bindEvents',
      value() {
        this.el.bindEvents({
          selectionChange: this._saveSelection, input: this._onInput, drop: this._onDrop, click: this._onClick, focus: this._onFocus, commit: this._onChange
        });
      }
    }, { key: '_unbindEvents', value() { this.el && this.el.unbindEvents(); } }, { key: '_fireEvent', value(t) { for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), u = 1; u < e; u++)n[u - 1] = arguments[u]; const r = this._listeners[t]; r && r.forEach((t => t.apply(void 0, n))); } }, { key: 'selectionStart', get() { return this._cursorChanging ? this._changingCursorPos : this.el.selectionStart; } }, { key: 'cursorPos', get() { return this._cursorChanging ? this._changingCursorPos : this.el.selectionEnd; }, set(t) { this.el && this.el.isActive && (this.el.select(t, t), this._saveSelection()); } }, { key: '_saveSelection', value() { this.value !== this.el.value && console.warn('Element value was changed outside of mask. Syncronize mask using `mask.updateValue()` to work properly.'), this._selection = { start: this.selectionStart, end: this.cursorPos }; } }, { key: 'updateValue', value() { this.masked.value = this.el.value, this._value = this.masked.value; } }, { key: 'updateControl', value() { const t = this.masked.unmaskedValue; const e = this.masked.value; const n = this.unmaskedValue !== t || this.value !== e; this._unmaskedValue = t, this._value = e, this.el.value !== e && (this.el.value = e), n && this._fireChangeEvents(); } }, { key: 'updateOptions', value(t) { const e = t.mask; const n = Gt(t, ['mask']); const u = !this.maskEquals(e); const r = !he(this.masked, n); u && (this.mask = e), r && this.masked.updateOptions(n), (u || r) && this.updateControl(); } }, { key: 'updateCursor', value(t) { t != null && (this.cursorPos = t, this._delayUpdateCursor(t)); } }, { key: '_delayUpdateCursor', value(t) { const e = this; this._abortUpdateCursor(), this._changingCursorPos = t, this._cursorChanging = setTimeout((() => { e.el && (e.cursorPos = e._changingCursorPos, e._abortUpdateCursor()); }), 10); } }, { key: '_fireChangeEvents', value() { this._fireEvent('accept', this._inputEvent), this.masked.isComplete && this._fireEvent('complete', this._inputEvent); } }, { key: '_abortUpdateCursor', value() { this._cursorChanging && (clearTimeout(this._cursorChanging), delete this._cursorChanging); } }, { key: 'alignCursor', value() { this.cursorPos = this.masked.nearestInputPos(this.cursorPos, re); } }, { key: 'alignCursorFriendly', value() { this.selectionStart === this.cursorPos && this.alignCursor(); } }, { key: 'on', value(t, e) { return this._listeners[t] || (this._listeners[t] = []), this._listeners[t].push(e), this; } }, { key: 'off', value(t, e) { if (!this._listeners[t]) return this; if (!e) return delete this._listeners[t], this; const n = this._listeners[t].indexOf(e); return n >= 0 && this._listeners[t].splice(n, 1), this; } }, { key: '_onInput', value(t) { if (this._inputEvent = t, this._abortUpdateCursor(), !this._selection) return this.updateValue(); const e = new ce(this.el.value, this.cursorPos, this.value, this._selection); const n = this.masked.rawInputValue; const u = this.masked.splice(e.startChangePos, e.removed.length, e.inserted, e.removeDirection).offset; const r = n === this.masked.rawInputValue ? e.removeDirection : ue; const i = this.masked.nearestInputPos(e.startChangePos + u, r); this.updateControl(), this.updateCursor(i), delete this._inputEvent; } }, { key: '_onChange', value() { this.value !== this.el.value && this.updateValue(), this.masked.doCommit(), this.updateControl(), this._saveSelection(); } }, { key: '_onDrop', value(t) { t.preventDefault(), t.stopPropagation(); } }, { key: '_onFocus', value(t) { this.alignCursorFriendly(); } }, { key: '_onClick', value(t) { this.alignCursorFriendly(); } }, { key: 'destroy', value() { this._unbindEvents(), this._listeners.length = 0, delete this.el; } }]), t;
  }()); de.InputMask = Me; const xe = (function (t) { Yt(n, t); const e = $t(n); function n() { return Ut(this, n), e.apply(this, arguments); } return Ht(n, [{ key: '_update', value(t) { t.enum && (t.mask = '*'.repeat(t.enum[0].length)), Xt(Zt(n.prototype), '_update', this).call(this, t); } }, { key: 'doValidate', value() { for (var t, e = this, u = arguments.length, r = new Array(u), i = 0; i < u; i++)r[i] = arguments[i]; return this.enum.some((t => t.indexOf(e.unmaskedValue) >= 0)) && (t = Xt(Zt(n.prototype), 'doValidate', this)).call.apply(t, [this].concat(r)); } }]), n; }(Ce)); de.MaskedEnum = xe; const Pe = (function (t) { Yt(n, t); const e = $t(n); function n(t) { return Ut(this, n), e.call(this, { ...n.DEFAULTS, ...t }); } return Ht(n, [{ key: '_update', value(t) { Xt(Zt(n.prototype), '_update', this).call(this, t), this._updateRegExps(); } }, { key: '_updateRegExps', value() { const t = `^${this.allowNegative ? '[+|\\-]?' : ''}`; const e = `${this.scale ? `(${le(this.radix)}\\d{0,${this.scale}})?` : ''}$`; this._numberRegExpInput = new RegExp(`${t}(0|([1-9]+\\d*))?${e}`), this._numberRegExp = new RegExp(`${t}\\d*${e}`), this._mapToRadixRegExp = new RegExp(`[${this.mapToRadix.map(le).join('')}]`, 'g'), this._thousandsSeparatorRegExp = new RegExp(le(this.thousandsSeparator), 'g'); } }, { key: '_removeThousandsSeparators', value(t) { return t.replace(this._thousandsSeparatorRegExp, ''); } }, { key: '_insertThousandsSeparators', value(t) { const e = t.split(this.radix); return e[0] = e[0].replace(/\B(?=(\d{3})+(?!\d))/g, this.thousandsSeparator), e.join(this.radix); } }, { key: 'doPrepare', value(t) { for (var e, u = arguments.length, r = new Array(u > 1 ? u - 1 : 0), i = 1; i < u; i++)r[i - 1] = arguments[i]; return (e = Xt(Zt(n.prototype), 'doPrepare', this)).call.apply(e, [this, this._removeThousandsSeparators(t.replace(this._mapToRadixRegExp, this.radix))].concat(r)); } }, { key: '_separatorsCount', value(t) { for (var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], n = 0, u = 0; u < t; ++u) this._value.indexOf(this.thousandsSeparator, u) === u && (++n, e && (t += this.thousandsSeparator.length)); return n; } }, { key: '_separatorsCountFromSlice', value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._value; return this._separatorsCount(this._removeThousandsSeparators(t).length, !0); } }, { key: 'extractInput', value() { let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length; const u = arguments.length > 2 ? arguments[2] : void 0; const r = this._adjustRangeWithSeparators(t, e); const i = te(r, 2); return t = i[0], e = i[1], this._removeThousandsSeparators(Xt(Zt(n.prototype), 'extractInput', this).call(this, t, e, u)); } }, { key: '_appendCharRaw', value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if (!this.thousandsSeparator) return Xt(Zt(n.prototype), '_appendCharRaw', this).call(this, t, e); const u = e.tail && e._beforeTailState ? e._beforeTailState._value : this._value; const r = this._separatorsCountFromSlice(u); this._value = this._removeThousandsSeparators(this.value); const i = Xt(Zt(n.prototype), '_appendCharRaw', this).call(this, t, e); this._value = this._insertThousandsSeparators(this._value); const a = e.tail && e._beforeTailState ? e._beforeTailState._value : this._value; const s = this._separatorsCountFromSlice(a); return i.tailShift += (s - r) * this.thousandsSeparator.length, i.skip = !i.rawInserted && t === this.thousandsSeparator, i; } }, { key: '_findSeparatorAround', value(t) { if (this.thousandsSeparator) { const e = t - this.thousandsSeparator.length + 1; const n = this.value.indexOf(this.thousandsSeparator, e); if (n <= t) return n; } return -1; } }, { key: '_adjustRangeWithSeparators', value(t, e) { const n = this._findSeparatorAround(t); n >= 0 && (t = n); const u = this._findSeparatorAround(e); return u >= 0 && (e = u + this.thousandsSeparator.length), [t, e]; } }, { key: 'remove', value() { let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length; const n = this._adjustRangeWithSeparators(t, e); const u = te(n, 2); t = u[0], e = u[1]; const r = this.value.slice(0, t); const i = this.value.slice(e); const a = this._separatorsCount(r.length); this._value = this._insertThousandsSeparators(this._removeThousandsSeparators(r + i)); const s = this._separatorsCountFromSlice(r); return new fe({ tailShift: (s - a) * this.thousandsSeparator.length }); } }, { key: 'nearestInputPos', value(t, e) { if (!this.thousandsSeparator) return t; switch (e) { case ue: case re: case ie: var n = this._findSeparatorAround(t - 1); if (n >= 0) { const u = n + this.thousandsSeparator.length; if (t < u || this.value.length <= u || e === ie) return n; } break; case ae: case se: var r = this._findSeparatorAround(t); if (r >= 0) return r + this.thousandsSeparator.length; } return t; } }, { key: 'doValidate', value(t) { let e = (t.input ? this._numberRegExpInput : this._numberRegExp).test(this._removeThousandsSeparators(this.value)); if (e) { const u = this.number; e = e && !isNaN(u) && (this.min == null || this.min >= 0 || this.min <= this.number) && (this.max == null || this.max <= 0 || this.number <= this.max); } return e && Xt(Zt(n.prototype), 'doValidate', this).call(this, t); } }, { key: 'doCommit', value() { if (this.value) { const t = this.number; let e = t; this.min != null && (e = Math.max(e, this.min)), this.max != null && (e = Math.min(e, this.max)), e !== t && (this.unmaskedValue = String(e)); let u = this.value; this.normalizeZeros && (u = this._normalizeZeros(u)), this.padFractionalZeros && (u = this._padFractionalZeros(u)), this._value = u; }Xt(Zt(n.prototype), 'doCommit', this).call(this); } }, { key: '_normalizeZeros', value(t) { const e = this._removeThousandsSeparators(t).split(this.radix); return e[0] = e[0].replace(/^(\D*)(0*)(\d*)/, ((t, e, n, u) => e + u)), t.length && !/\d$/.test(e[0]) && (e[0] += '0'), e.length > 1 && (e[1] = e[1].replace(/0*$/, ''), e[1].length || (e.length = 1)), this._insertThousandsSeparators(e.join(this.radix)); } }, { key: '_padFractionalZeros', value(t) { if (!t) return t; const e = t.split(this.radix); return e.length < 2 && e.push(''), e[1] = e[1].padEnd(this.scale, '0'), e.join(this.radix); } }, { key: 'unmaskedValue', get() { return this._removeThousandsSeparators(this._normalizeZeros(this.value)).replace(this.radix, '.'); }, set(t) { Qt(Zt(n.prototype), 'unmaskedValue', t.replace('.', this.radix), this, !0); } }, { key: 'typedValue', get() { return Number(this.unmaskedValue); }, set(t) { Qt(Zt(n.prototype), 'unmaskedValue', String(t), this, !0); } }, { key: 'number', get() { return this.typedValue; }, set(t) { this.typedValue = t; } }, { key: 'allowNegative', get() { return this.signed || this.min != null && this.min < 0 || this.max != null && this.max < 0; } }]), n; }(ve)); Pe.DEFAULTS = {
    radix: ',', thousandsSeparator: '', mapToRadix: ['.'], scale: 2, signed: !1, normalizeZeros: !0, padFractionalZeros: !1
  }, de.MaskedNumber = Pe; const Oe = (function (t) { Yt(n, t); const e = $t(n); function n() { return Ut(this, n), e.apply(this, arguments); } return Ht(n, [{ key: '_update', value(t) { t.mask && (t.validate = t.mask), Xt(Zt(n.prototype), '_update', this).call(this, t); } }]), n; }(ve)); de.MaskedFunction = Oe; const Te = (function (t) {
    Yt(n, t); const e = $t(n); function n(t) { let u; return Ut(this, n), (u = e.call(this, { ...n.DEFAULTS, ...t })).currentMask = null, u; } return Ht(n, [{ key: '_update', value(t) { Xt(Zt(n.prototype), '_update', this).call(this, t), 'mask' in t && (this.compiledMasks = Array.isArray(t.mask) ? t.mask.map((t => ge(t))) : []); } }, { key: '_appendCharRaw', value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const n = this._applyDispatch(t, e); return this.currentMask && n.aggregate(this.currentMask._appendChar(t, e)), n; } }, { key: '_applyDispatch', value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ''; const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const n = e.tail && e._beforeTailState != null ? e._beforeTailState._value : this.value; const u = this.rawInputValue; const r = e.tail && e._beforeTailState != null ? e._beforeTailState._rawInputValue : u; const i = u.slice(r.length); const a = this.currentMask; const s = new fe(); const o = a && a.state; if (this.currentMask = this.doDispatch(t, { ...e }), this.currentMask) if (this.currentMask !== a) { if (this.currentMask.reset(), r) { const l = this.currentMask.append(r, { raw: !0 }); s.tailShift = l.inserted.length - n.length; }i && (s.tailShift += this.currentMask.append(i, { raw: !0, tail: !0 }).tailShift); } else this.currentMask.state = o; return s; } }, { key: '_appendPlaceholder', value() { const t = this._applyDispatch.apply(this, arguments); return this.currentMask && t.aggregate(this.currentMask._appendPlaceholder()), t; } }, { key: 'doDispatch', value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; return this.dispatch(t, this, e); } }, { key: 'doValidate', value() { for (var t, e, u = arguments.length, r = new Array(u), i = 0; i < u; i++)r[i] = arguments[i]; return (t = Xt(Zt(n.prototype), 'doValidate', this)).call.apply(t, [this].concat(r)) && (!this.currentMask || (e = this.currentMask).doValidate.apply(e, r)); } }, { key: 'reset', value() { this.currentMask && this.currentMask.reset(), this.compiledMasks.forEach((t => t.reset())); } }, { key: 'value', get() { return this.currentMask ? this.currentMask.value : ''; }, set(t) { Qt(Zt(n.prototype), 'value', t, this, !0); } }, { key: 'unmaskedValue', get() { return this.currentMask ? this.currentMask.unmaskedValue : ''; }, set(t) { Qt(Zt(n.prototype), 'unmaskedValue', t, this, !0); } }, { key: 'typedValue', get() { return this.currentMask ? this.currentMask.typedValue : ''; }, set(t) { let e = String(t); this.currentMask && (this.currentMask.typedValue = t, e = this.currentMask.unmaskedValue), this.unmaskedValue = e; } }, { key: 'isComplete', get() { return !!this.currentMask && this.currentMask.isComplete; } }, { key: 'remove', value() { let t; const e = new fe(); this.currentMask && e.aggregate((t = this.currentMask).remove.apply(t, arguments)).aggregate(this._applyDispatch()); return e; } }, {
      key: 'state',
      get() {
        return {
          ...Xt(Zt(n.prototype), 'state', this), _rawInputValue: this.rawInputValue, compiledMasks: this.compiledMasks.map((t => t.state)), currentMaskRef: this.currentMask, currentMask: this.currentMask && this.currentMask.state
        };
      },
      set(t) { const e = t.compiledMasks; const u = t.currentMaskRef; const r = t.currentMask; const i = Gt(t, ['compiledMasks', 'currentMaskRef', 'currentMask']); this.compiledMasks.forEach(((t, n) => t.state = e[n])), u != null && (this.currentMask = u, this.currentMask.state = r), Qt(Zt(n.prototype), 'state', i, this, !0); }
    }, { key: 'extractInput', value() { let t; return this.currentMask ? (t = this.currentMask).extractInput.apply(t, arguments) : ''; } }, { key: 'extractTail', value() { for (var t, e, u = arguments.length, r = new Array(u), i = 0; i < u; i++)r[i] = arguments[i]; return this.currentMask ? (t = this.currentMask).extractTail.apply(t, r) : (e = Xt(Zt(n.prototype), 'extractTail', this)).call.apply(e, [this].concat(r)); } }, { key: 'doCommit', value() { this.currentMask && this.currentMask.doCommit(), Xt(Zt(n.prototype), 'doCommit', this).call(this); } }, { key: 'nearestInputPos', value() { for (var t, e, u = arguments.length, r = new Array(u), i = 0; i < u; i++)r[i] = arguments[i]; return this.currentMask ? (t = this.currentMask).nearestInputPos.apply(t, r) : (e = Xt(Zt(n.prototype), 'nearestInputPos', this)).call.apply(e, [this].concat(r)); } }, { key: 'overwrite', get() { return this.currentMask ? this.currentMask.overwrite : Xt(Zt(n.prototype), 'overwrite', this); }, set(t) { console.warn('"overwrite" option is not available in dynamic mask, use this option in siblings'); } }]), n;
  }(ve)); Te.DEFAULTS = { dispatch(t, e, n) { if (e.compiledMasks.length) { const u = e.rawInputValue; const r = e.compiledMasks.map(((e, r) => (e.reset(), e.append(u, { raw: !0 }), e.append(t, n), { weight: e.rawInputValue.length, index: r }))); return r.sort(((t, e) => e.weight - t.weight)), e.compiledMasks[r[0].index]; } } }, de.MaskedDynamic = Te; const Ie = { MASKED: 'value', UNMASKED: 'unmaskedValue', TYPED: 'typedValue' }; function je(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Ie.MASKED; const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Ie.MASKED; const u = ge(t); return function (t) { return u.runIsolated((u => (u[e] = t, u[n]))); }; } function Ve(t) { for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), u = 1; u < e; u++)n[u - 1] = arguments[u]; return je.apply(void 0, n)(t); }de.PIPE_TYPE = Ie, de.createPipe = je, de.pipe = Ve; try { globalThis.IMask = de; } catch (t) {}t.HTMLContenteditableMaskElement = we, t.HTMLMaskElement = Be, t.InputMask = Me, t.MaskElement = De, t.Masked = ve, t.MaskedDate = Se, t.MaskedDynamic = Te, t.MaskedEnum = xe, t.MaskedFunction = Oe, t.MaskedNumber = Pe, t.MaskedPattern = Ce, t.MaskedRange = Fe, t.MaskedRegExp = be, t.PIPE_TYPE = Ie, t.createMask = ge, t.createPipe = je, t.default = de, t.pipe = Ve, Object.defineProperty(t, '__esModule', { value: !0 });
})));
